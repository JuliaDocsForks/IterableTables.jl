<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integration Guide · IterableTables.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>IterableTables.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="userguide.html">User Guide</a></li><li class="current"><a class="toctext" href="integrationguide.html">Integration Guide</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Overview-1">Overview</a></li><li class="toplevel"><a class="toctext" href="#Consuming-iterable-tables-1">Consuming iterable tables</a></li><li><a class="toctext" href="#Reusing-an-existing-consumer-of-iterable-tables-1">Reusing an existing consumer of iterable tables</a></li><li><a class="toctext" href="#Coding-a-complete-conversion-1">Coding a complete conversion</a></li><li class="toplevel"><a class="toctext" href="#Creating-an-iterable-table-source-1">Creating an iterable table source</a></li></ul></li><li><a class="toctext" href="developerguide.html">Developer Guide</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="integrationguide.html">Integration Guide</a></li></ul><a class="edit-page" href="https://github.com/davidanthoff/IterableTables.jl/tree/a081a6942ce5918bfbfdd856090e422b692867e1/docs/src/integrationguide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Integration-Guide-1" href="#Integration-Guide-1">Integration Guide</a></h1><p>This guide describes how package authors can integrate their own packages with the <code>IterableTables</code> ecosystem. Specifically, it explains how one can turn a type into an iterable table and how one can write code that consumes iterable tables.</p><h1><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h1><p>For now I recommend that all integrations with IterableTables should live in the IterableTables package. This is a temporary solution until the interface in IterableTables is more stable, at which point integrations will be moved into the packages that they integrate. So new integrations should at this point ideally be submitted as pull requests against the <a href="https://github.com/davidanthoff/IterableTables.jl">IterableTables repository</a>. Specifically, each integration should be put into a file in the folder <code>src/integrations</code>, and the filename should be the name of the package that is being integrated. The code in that file should live in a <code>@require</code> block (see one of the existing integrations for an example).</p><h1><a class="nav-anchor" id="Consuming-iterable-tables-1" href="#Consuming-iterable-tables-1">Consuming iterable tables</a></h1><p>One cannot dispatch on an iterable table because iterable tables don&#39;t have a common super type. Instead one has to add a method that takes any type as an argument to consume an iterable table. For conversions between types it is recommended that one adds a constructor that takes one argument without any type restriction that can convert an iterable table into the target type. For example, if one has added a new table type called <code>MyTable</code>, one would add a constructor with this method signature for this type: <code>function MyTable(iterable_table)</code>. For other situations, for example a plotting function, one also would add a method without any type restriction, for example <code>plot(iterable_table)</code>.</p><p>The first step inside any function that consumes iterable tables is to check whether the argument that was passed is actually an iterable table or not. This can easily be done with the <code>isiterabletable</code> function. For example, the constructor for a new table type might start like this:</p><pre><code class="language-julia">function MyTable(source)
    isiterabletable(source) || error(&quot;Argument is not an iterable table.&quot;)

    # Code that converts things follows
end</code></pre><p>Once it has been established that the argument is actually an iterable table there are multiple ways to proceed. The following two sections describe two options, which one is appropriate for a given situation depends on a variety of factors.</p><h2><a class="nav-anchor" id="Reusing-an-existing-consumer-of-iterable-tables-1" href="#Reusing-an-existing-consumer-of-iterable-tables-1">Reusing an existing consumer of iterable tables</a></h2><p>This option is by far the simplest way to add support for consuming an iterable table. Essentially the strategy is to reuse the conversion implementation of some other type. For example, one can simply convert the iterable table into a <code>DataFrame</code> right after one has checked that the argument of the function is actually an iterable table. Once the iterable table is converted to a <code>DataFrame</code>, one can use the standard API of <code>DataFrame</code>s to proceed. This strategy is especially simple for packages that already support interaction with <code>DataFrames</code> (or any of the other table types supported by IterableTables). The code for the <span>$MyTable$</span> constructor might look like this:</p><pre><code class="language-julia">function MyTable(source)
    isiterabletable(source) || error(&quot;Argument is not an iterable table.&quot;)

    df = DataFrame(source)
    return MyTable(df)
end</code></pre><p>This assumes that <code>MyTable</code> has another constructor that accepts a <code>DataFrame</code>.</p><p>Currently the most efficient table type for this kind of conversion is the <code>DataTable</code> type from the <a href="https://github.com/JuliaData/DataTables.jl">DataTables.jl</a> package. How efficient is this strategy in general? It really depends what is happening in the next step with say the <code>DataTable</code> one constructed. If the data will be copied into yet another data structure after it has been converted to a <code>DataTable</code>, one has added at least one unnecessary memory allocation in the conversion. For such a situation it is probably more efficient to manually code a complete version, as described in the next section. If, on the other hand, one for example requires a vector of values for each column of the table, this approach can be quite efficient: one can just access the vector in the <code>DataTable</code> and operate on that.</p><h2><a class="nav-anchor" id="Coding-a-complete-conversion-1" href="#Coding-a-complete-conversion-1">Coding a complete conversion</a></h2><p>[TODO]</p><h1><a class="nav-anchor" id="Creating-an-iterable-table-source-1" href="#Creating-an-iterable-table-source-1">Creating an iterable table source</a></h1><p>[TODO]</p><footer><hr/><a class="previous" href="userguide.html"><span class="direction">Previous</span><span class="title">User Guide</span></a><a class="next" href="developerguide.html"><span class="direction">Next</span><span class="title">Developer Guide</span></a></footer></article></body></html>
